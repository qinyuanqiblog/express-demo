#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require('../app');
var debug = require('debug')('express-demo:server');
var http = require('http');

var log = require('consola');
const path = require('path');
const os = require('os');
const localHost = getLocalIps()[0];
const commonUtils = require('../utils');

/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3000');
app.set('port', port);
log.success(' Your application is running here:http://' + localHost + ':' + port);

/**
 * Create HTTP server.
 */

var server = http.createServer(app);

/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);


const axios = require('axios')
const cheerio = require('cheerio')
const fs = require('fs');


// axios.get('https://wallhaven.cc/w/28kdom').then(res=>{

// }).catch(err=>{

// })

const reptileUrl = 'https://wallhaven.cc/toplist?page='
const saveDir = 'E:/myExpressDownload/toplist2/'
let currentPage = 6
const maxPage = 141

init()

/**
 * çˆ¬å–ä¸»ç¨‹åºå…¥å£
 * @param {number}  currentPage   ä¸€ç»„æ•°æ®æœ‰å¤šä¸ª
 * @param {number}  maxPage   ä¸€ç»„æ•°æ®æœ‰å¤šä¸ª
 * @param {string}  saveDir   ä¸€ç»„æ•°æ®æœ‰å¤šä¸ª
 */
async function init() {
    log.info('ä¸»ç¨‹åºå¼€å§‹å¯åŠ¨ï¼Œè¯·æ‚¨è€å¿ƒç­‰å¾…~')
    log.info(`å¼€å§‹çˆ¬å–${reptileUrl}çš„å›¾ç‰‡`)
    log.info(`æ–‡ä»¶å°†ä¼šè¢«ä¿å­˜åˆ°ä»¥ä¸‹åœ°å€ä¸­ï¼š${saveDir}`)

    // åˆ¤æ–­æœ¬åœ°å­˜å‚¨æ–‡ä»¶å¤¹æ˜¯å¦å­˜åœ¨
    if (!fs.existsSync(saveDir)) {
        log.info('ç›®æ ‡æ–‡ä»¶ä¸å­˜åœ¨ï¼Œå¼€å§‹åˆ›å»ºæ–°çš„æ–‡ä»¶å¤¹~')
        fs.mkdirSync(saveDir);
    }

    if (currentPage > maxPage) {
        log.error('è¶…å‡ºæœ€å¤§é¡µæ•°ï¼Œç¨‹åºè‡ªåŠ¨ç»ˆæ­¢')
        return false
    }
    const hrefList = []
    try {
        log.info(`å¼€å§‹çˆ¬å–ç¬¬${currentPage}é¡µ`)
        const websiteHtml = await axios.get(`${reptileUrl}${currentPage}`)
        const html = websiteHtml.data
        const $ = cheerio.load(html);
        $('.preview').each((i, v) => {
            const href = v.attribs.href
            href && hrefList.push(href)
        })
        log.info('å·²ç»æŠ“å–åˆ°æ‰€æœ‰çš„aè¿æ¥~')
        log.info('å‡†å¤‡ä¸‹è½½å’¯~')
        log.info(`hrefList ä¸ªæ•°==>`, hrefList.length)

       download(hrefList)

        
    } catch (error) {
        log.error(`çˆ¬å–é”™è¯¯ï¼Œé”™è¯¯ä¿¡æ¯å¦‚ä¸‹==>`, error)
    }
}


async function download(hrefList) {
    if (!hrefList.length) {
        log.error('æ²¡æœ‰å›¾ç‰‡äº†ï¼Œç¨‹åºç»ˆæ­¢å’¯~')
    }
  // æœ‰äº›ç½‘ç«™é™åˆ¶ä¸èƒ½å‘é€å¤ªå¤šè¯·æ±‚ï¼Œä¸€èˆ¬10ä¸ªéƒ½å¯ä»¥è¿‡
  const resultList = await findPicture(hrefList.splice(0, 10))
  const downloadArray = resultList.map((v, i) => {
      const $ = cheerio.load(v.data);
      const currentImg = $('.fit img')
      const url = currentImg.attr('src')
      const fileName = currentImg.attr('data-wallpaper-id')
      return {
          url,
          fileName
      }
  })
  log.info('å›¾ç‰‡è§£æå®Œæ¯•ï¼Œå·²ç»æŠ“å–åˆ°æ‰€æœ‰çš„åœ°å€~')
  await downloadPicture(downloadArray)
  download(hrefList)
  sleep()
}

function sleep() {
    currentPage++
    const sleepTimeout = commonUtils.getRandomNumber(1, 20)
    let copyTimeout = sleepTimeout
    log.info(`çˆ¬å¤ªå¤šäº†ï¼Œæœ‰ç‚¹ç´¯äº†ï¼Œä¼‘æ¯${sleepTimeout}ç§’ï¼Œåå†ç»§ç»­ğŸ˜„`)
    const logTimer = setInterval(() => {
        if (copyTimeout <= 1) {
            clearInterval(logTimer)
        }
        log.success(`ä¼‘æ¯${--copyTimeout}ç§’åå¼€å§‹æ€•çˆ¬ç¬¬${currentPage}é¡µ`)
    }, 1000);
    setTimeout(() => {
        init()
    }, sleepTimeout * 1000);
}

async function findPicture(aTagArray) {
    log.info('å¼€å§‹è§£æå›¾ç‰‡å†…å®¹~')
    const array = aTagArray.map(v => axios.get(v))
    return Promise.all(array)
}


function downloadPicture(pictureArray) {
    log.info('å¼€å§‹å‘é€è¯·æ±‚ä¸‹è½½å›¾ç‰‡~')
    return pictureArray.reduce((accumulator, currentValue, currentIndex, array) => {
        const promise = axios.get(`${currentValue.url}`, {
            responseType: 'stream'
        }).then(res => {
            const result = res.data.pipe(fs.createWriteStream(`${saveDir}${currentValue.fileName}.png`))
            log.success(`æˆåŠŸä¿å­˜å›¾ç‰‡åˆ°æœ¬åœ°ï¼Œä¿å­˜ä½ç½®==>${saveDir}${currentValue.fileName}.png`)
        })
        accumulator.push(promise)
        return accumulator
    }, [])
}







/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
    var port = parseInt(val, 10);

    if (isNaN(port)) {
        // named pipe
        return val;
    }

    if (port >= 0) {
        // port number
        return port;
    }

    return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
    if (error.syscall !== 'listen') {
        throw error;
    }

    var bind = typeof port === 'string' ?
        'Pipe ' + port :
        'Port ' + port;

    // handle specific listen errors with friendly messages
    switch (error.code) {
        case 'EACCES':
            console.error(bind + ' requires elevated privileges');
            process.exit(1);
            break;
        case 'EADDRINUSE':
            console.error(bind + ' is already in use');
            process.exit(1);
            break;
        default:
            throw error;
    }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
    var addr = server.address();
    var bind = typeof addr === 'string' ?
        'pipe ' + addr :
        'port ' + addr.port;
    debug('Listening on ' + bind);
}

/**
 *è·å–æœ¬åœ°IP
 *
 * @param {boolean}  æ˜¯å¦æ˜¾ç¤ºipb6
 * @returns {object} åŒ…å«Ipçš„æ•°ç»„
 *
 * console.log('æœ¬æœºipåœ°å€(ä¸åŒ…æ‹¬Ipv6):', getLocalIps());
 * console.log('æœ¬æœºipåœ°å€(åŒ…æ‹¬Ipv6):', getLocalIps(true));
 *
 */
function getLocalIps(flagIpv6) {
    var ifaces = os.networkInterfaces();
    var ips = [];
    var func = function(details) {
        if (!flagIpv6 && details.family === 'IPv6') {
            return;
        }
        ips.push(details.address);
    };
    for (var dev in ifaces) {
        ifaces[dev].forEach(func);
    }
    return ips;
}