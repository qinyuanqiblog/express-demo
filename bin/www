#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require('../app');
var debug = require('debug')('express-demo:server');
var http = require('http');



// 日志
class Log {
    constructor() {
        this.consoleLog = console.log
    }
    info(msg) {
        this.consoleLog(chalk.blue(msg))
    }
    success(msg) {
        this.consoleLog(chalk.green(msg))
    }
    error(msg) {
        this.consoleLog(chalk.red(msg))
    }
}

// 
var chalk = require('chalk');
const log = new Log()
const path = require('path');
const os = require('os');
const localHost = getLocalIps()[0];
const commonUtils = require('../utils');
const axiosRequest = require('../utils/request');





/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3000');
app.set('port', port);
log.success(' Your application is running here:http://' + localHost + ':' + port);

/**
 * Create HTTP server.
 */

var server = http.createServer(app);

/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);


const cheerio = require('cheerio')
const fs = require('fs');


// 爬虫入口
class Reptile {
    constructor({
        reptileUrl,
        saveDir,
        excelFileName = '爬虫excel报告',
        maxPage = 20,
    }) {
        // 爬取的网站
        this.reptileUrl = reptileUrl;
        // 保存的文件夹
        this.saveDir = saveDir;
        // excel文件名
        this.excelFileName = excelFileName;
        // 当前页数
        this.currentPage = 1;
        // 最大页数
        this.maxPage = maxPage;
        // 所有的源数据合集
        this.imgUrlList = []
        // 下载成功的地址合集
        this.uploadSuccessArray = []
        // 下载失败的地址合集
        this.uploadFailArray = []

        this.initConfig()
        this.init()

        // this.connectMysql()
    }
    /**
     * 初始化配置
     */
    initConfig() {
        log.info('主程序开始启动，请您耐心等待~')
        log.info(`开始爬取${this.reptileUrl}的图片`)
        log.info(`文件将会被保存到以下地址中：${this.saveDir}`)
        // 判断本地存储文件夹是否存在
        if (!fs.existsSync(this.saveDir)) {
            log.info('目标文件不存在，开始创建新的文件夹~')
            fs.mkdirSync(this.saveDir);
        }
    }
    /**
     * 爬取主程序入口
     */
    async init() {
        if (this.currentPage > this.maxPage) {
            log.error('超出最大页数，停止收集源数据，开始爬取图片~')
            try {
                const downloadTimer = setInterval(() => {
                    if (!this.imgUrlList.length) {
                        log.error('没有更多了，收工了~~~~')
                        clearInterval(downloadTimer)
                        this.exportExcelFile()
                        this.connectMysql()
                        return false
                    }
                    log.success('开始轮询下载图片~')
                    this.downloadPicture()
                }, 10000);
            } catch (error) {
                log.error(`downloadPicture fail===>`, error)
            }
            return false
        }
        try {
            log.info(`开始爬取第${this.currentPage}页`)
            const websiteHtml = await axiosRequest.get(`${this.reptileUrl}${this.currentPage}`)
            const $ = cheerio.load(websiteHtml);
            $('.thumb img').each((i, v) => {
                const smallUrl = v.attribs['data-src'] || v.attribs.src
                const urlArray = smallUrl.split('/')
                const fileName = urlArray[urlArray.length - 1]
                const fullUrl = `https://w.wallhaven.cc/full/${fileName.substring(0, 2)}/wallhaven-${fileName}`
                const fileSize = $('.wall-res').eq(i).html()
                smallUrl && this.imgUrlList.push({
                    smallUrl: smallUrl,
                    fullUrl: fullUrl,
                    fileName,
                    fileSize,
                })

            })
            console.log(`this.imgUrlList 个数${this.imgUrlList.length}`)
            this.sleep()
        } catch (error) {
            log.error(`爬取错误，错误信息如下==>`, error)
        }
    }
    /**
     * 轮询
     */
    sleep() {
        this.currentPage++
        const sleepTimeout = commonUtils.getRandomNumber(1, 10)
        let copyTimeout = sleepTimeout
        log.info(`爬太多了，有点累了，休息${sleepTimeout}秒，后再继续😄`)
        const logTimer = setInterval(() => {
            if (copyTimeout <= 1) {
                clearInterval(logTimer)
            }
            log.success(`倒计时  ${--copyTimeout}   秒后开始继续干活~`)
        }, 1000);
        setTimeout(() => {
            this.init()
        }, sleepTimeout * 1000);
    }
    /**
     * 下载图片
     */
    downloadPicture() {
        log.info('开始发送请求下载图片~')
        return this.imgUrlList.splice(0, 10).reduce((accumulator, currentValue, currentIndex, array) => {
            const promise = axiosRequest.get(currentValue.fullUrl, {
                responseType: 'stream'
            }).then(res => {
                this.uploadSuccessArray.push(currentValue)
                const result = res.pipe(fs.createWriteStream(`${this.saveDir}${currentValue.fileName}`))
                log.success(`成功保存图片到本地，保存位置==>${this.saveDir}${currentValue.fileName}`)
            }).catch(err => {
                log.error(err)
                this.uploadFailArray.push(currentValue)
                log.error(`爬取图片失败 ，图片地址==> ${currentValue.fullUrl}`)
            })
            accumulator.push(promise)
            return accumulator
        }, [])
    }
    /**
     *  连接数据库
     */
    connectMysql() {
        var mysql = require('mysql2');
        var connection = mysql.createConnection({
            host: 'localhost',
            user: 'root',
            password: 'root',
            database: 'reptile-picture'
        });

        connection.connect();
        // 插入单条值
        // const  addSql = `INSERT INTO picture_info(fileName,fileSize,source,fullUrl,smallUrl, status) VALUES(0,1,2,3,4,5)`;
        const newArray = []
        this.uploadSuccessArray.forEach(v => {
            const {
                fullUrl,
                smallUrl,
                fileName,
                fileSize
            } = v || {}
            const itemArray = [fileName,  fileSize, this.reptileUrl, fullUrl, smallUrl, 1]
            newArray.push(itemArray)
        })
        this.uploadFailArray.forEach(v => {
            let {
                fullUrl,
                smallUrl,
                fileName,
                fileSize
            } = v || {}
            // 大部分小图是.jpg ， 但是大图是.png 的，就转化一下，不行就算咯
            fullUrl = fullUrl.replace(/.{1,4}$/, '.png')
            const itemArray = [fileName,fileSize, this.reptileUrl, fullUrl, smallUrl, 0]
            newArray.push(itemArray)
        })


        // 插入多条值有重复的不插入，必须设置主键，不然不生效
        const  addSql = `INSERT IGNORE  INTO picture_info(fileName,fileSize,source,fullUrl,smallUrl,status) VALUES ?`;
        //增
        connection.query(addSql, [newArray], function(err, result) {
            if (err) {
                log.error(`插入失败 ==>  ,${ err.message }`)
                return;
            }
            log.success('插入成功了:', result);
        });

        connection.end();
    }
    /**
     *  生成excel 报告
     */
    exportExcelFile() {
        log.info('开始生成excel报告~')
        // 导出excel
        const ExcelJS = require('exceljs');
        const workbook = new ExcelJS.Workbook()
        const worksheet = workbook.addWorksheet('My Sheet');
        workbook.creator = 'Me';
        workbook.lastModifiedBy = 'Her';
        workbook.created = new Date();
        workbook.modified = new Date();
        workbook.lastPrinted = new Date();;


        log.success(`成功保存 ${this.uploadSuccessArray.length} 个`)
        log.success(`保存失败 ${this.uploadFailArray.length} 个`)

        const newArray = []
        this.uploadSuccessArray.forEach(v => {
            const {
                fullUrl,
                smallUrl,
                fileName,
                fileSize
            } = v || {}
            const itemArray = [fileName,  fileSize, this.reptileUrl, fullUrl, smallUrl, '成功']
            newArray.push(itemArray)
        })
        this.uploadFailArray.forEach(v => {
            const {
                fullUrl,
                smallUrl,
                fileName,
                fileSize
            } = v || {}
            const itemArray = [fileName,  fileSize, this.reptileUrl, fullUrl, smallUrl, '失败']
            newArray.push(itemArray)
        })



        // 将表格添加到工作表
        worksheet.addTable({
            name: 'MyTable',
            ref: 'A1',
            headerRow: true,
            // totalsRow: true,
            style: {
                theme: 'TableStyleLight1'
            },
            columns: [{
                    name: '文件名',
                    width: 50,
                },
                {
                    name: '图片大小',
                    width: 50,
                },
                {
                    name: '来源',
                    width: 50,
                },
                {
                    name: '大图地址',
                    width: 50,
                },
                {
                    name: '小图地址',
                    width: 50,
                },
                {
                    name: '是否成功下载',
                    width: 50,
                },
            ],
            rows: newArray,
        });

        // 写入文件
        workbook.xlsx.writeFile(`${this.excelFileName}.xlsx`);
        log.success('生成excel报告成功~')
    }
}


// 调用入口
new Reptile({
    reptileUrl: 'https://wallhaven.cc/hot?page=',
    saveDir: 'E:/myExpressDownload/hot/',
    maxPage: 3,
})









/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
    var port = parseInt(val, 10);

    if (isNaN(port)) {
        // named pipe
        return val;
    }

    if (port >= 0) {
        // port number
        return port;
    }

    return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
    if (error.syscall !== 'listen') {
        throw error;
    }

    var bind = typeof port === 'string' ?
        'Pipe ' + port :
        'Port ' + port;

    // handle specific listen errors with friendly messages
    switch (error.code) {
        case 'EACCES':
            console.error(bind + ' requires elevated privileges');
            process.exit(1);
            break;
        case 'EADDRINUSE':
            console.error(bind + ' is already in use');
            process.exit(1);
            break;
        default:
            throw error;
    }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
    var addr = server.address();
    var bind = typeof addr === 'string' ?
        'pipe ' + addr :
        'port ' + addr.port;
    debug('Listening on ' + bind);
}

/**
 *获取本地IP
 *
 * @param {boolean}  是否显示ipb6
 * @returns {object} 包含Ip的数组
 *
 * console.log('本机ip地址(不包括Ipv6):', getLocalIps());
 * console.log('本机ip地址(包括Ipv6):', getLocalIps(true));
 *
 */
function getLocalIps(flagIpv6) {
    var ifaces = os.networkInterfaces();
    var ips = [];
    var func = function(details) {
        if (!flagIpv6 && details.family === 'IPv6') {
            return;
        }
        ips.push(details.address);
    };
    for (var dev in ifaces) {
        ifaces[dev].forEach(func);
    }
    return ips;
}