#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require('../app');
var debug = require('debug')('express-demo:server');
var http = require('http');



// æ—¥å¿—
class Log {
    constructor() {
        this.consoleLog = console.log
    }
    info(msg) {
        this.consoleLog(chalk.blue(msg))
    }
    success(msg) {
        this.consoleLog(chalk.green(msg))
    }
    error(msg) {
        this.consoleLog(chalk.red(msg))
    }
}

// 
var chalk = require('chalk');
const log = new Log()
const path = require('path');
const os = require('os');
const localHost = getLocalIps()[0];
const commonUtils = require('../utils');
const axiosRequest = require('../utils/request');





/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3000');
app.set('port', port);
log.success(' Your application is running here:http://' + localHost + ':' + port);

/**
 * Create HTTP server.
 */

var server = http.createServer(app);

/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);


const cheerio = require('cheerio')
const fs = require('fs');


// çˆ¬è™«å…¥å£
class Reptile {
    constructor({
        reptileUrl,
        saveDir,
        excelFileName = 'çˆ¬è™«excelæŠ¥å‘Š',
        maxPage = 20,
        handleType = 'paging'
    }) {
        // çˆ¬å–çš„ç½‘ç«™
        this.reptileUrl = reptileUrl;
        // ä¿å­˜çš„æ–‡ä»¶å¤¹
        this.saveDir = saveDir;
        // excelæ–‡ä»¶å
        this.excelFileName = excelFileName;
        // å½“å‰é¡µæ•°
        this.currentPage = 1;
        // æœ€å¤§é¡µæ•°
        this.maxPage = maxPage;
        // çˆ¬å–ç±»å‹ ï¼Œä¸åŒç½‘ç«™å¯èƒ½å¯¹åº”ä¸åŒçš„çˆ¬å–æ–¹å¼
        this.handleType = handleType;
        // æ‰€æœ‰çš„æºæ•°æ®åˆé›†
        this.imgUrlList = []
        // ä¸‹è½½æˆåŠŸçš„åœ°å€åˆé›†
        this.uploadSuccessArray = []
        // ä¸‹è½½å¤±è´¥çš„åœ°å€åˆé›†
        this.uploadFailArray = []

        this.initConfig()
        this.init()
    }
    /**
     * åˆå§‹åŒ–é…ç½®
     */
    initConfig() {
        log.info('ä¸»ç¨‹åºå¼€å§‹å¯åŠ¨ï¼Œè¯·æ‚¨è€å¿ƒç­‰å¾…~')
        log.info(`å¼€å§‹çˆ¬å–${this.reptileUrl}çš„å›¾ç‰‡`)
        log.info(`æ–‡ä»¶å°†ä¼šè¢«ä¿å­˜åˆ°ä»¥ä¸‹åœ°å€ä¸­ï¼š${this.saveDir}`)
        // åˆ¤æ–­æœ¬åœ°å­˜å‚¨æ–‡ä»¶å¤¹æ˜¯å¦å­˜åœ¨
        if (!fs.existsSync(this.saveDir)) {
            log.error('ç›®æ ‡æ–‡ä»¶ä¸å­˜åœ¨ï¼Œå¼€å§‹åˆ›å»ºæ–°çš„æ–‡ä»¶å¤¹~')
            fs.mkdirSync(this.saveDir);
        }
    }
    /**
     * çˆ¬å–ä¸»ç¨‹åºå…¥å£
     */
    async init() {
        const strategyName = this.reptileUrl.split('/')[2]
        try {
            log.info(`å¼€å§‹çˆ¬å–ç¬¬${this.currentPage}é¡µ`)
            const fn = this.initStrategy()[strategyName]
            if (strategyName && fn && typeof fn === 'function') {
                fn.apply(this)
            } else {
                log.error('initæ–¹æ³•å¼‚å¸¸ï¼Œæ²¡æœ‰å¤„ç†çš„æ–¹å¼ï¼Œç¨‹åºç»ˆæ­¢å’¯ï¼ï¼ï¼')
                return false
            }
        } catch (error) {
            log.error(`çˆ¬å–é”™è¯¯ï¼Œé”™è¯¯ä¿¡æ¯å¦‚ä¸‹==>`, error)
        }
    }
    /**
     * åˆå§‹åŒ–çš„ç­–ç•¥æ¨¡å¼ï¼Œä¸åŒç½‘ç«™å¯èƒ½ä¸ä¸€æ ·çš„ç­–ç•¥ï¼Œ
     * @return {promise} è¿”å›ä¸€ä¸ªasync çš„å¼‚æ­¥å‡½æ•°
     */
    initStrategy() {
        return {
            // wallhaven çƒ­é—¨çš„é€»è¾‘ï¼Œè¿™ä¸ªç½‘ç«™å¯ä»¥åœ¨å½“å‰é¡µé¢è¿›è¡Œåˆ†é¡µï¼Œç„¶åæ”¶é›†æ•°æ®
            async 'wallhaven.cc'() {
                const websiteHtml = await axiosRequest.get(`${this.reptileUrl}${this.currentPage}`)
                const $ = cheerio.load(websiteHtml);
                $('.thumb img').each((i, v) => {
                    const smallUrl = v.attribs['data-src'] || v.attribs.src
                    const urlArray = smallUrl.split('/')
                    const fileName = urlArray[urlArray.length - 1]
                    const fullUrl = `https://w.wallhaven.cc/full/${fileName.substring(0, 2)}/wallhaven-${fileName}`
                    const fileSize = $('.wall-res').eq(i).html()
                    smallUrl && this.imgUrlList.push({
                        smallUrl: smallUrl,
                        fullUrl: fullUrl,
                        fileName,
                        fileSize,
                    })
                })
                console.log(`${ this.imgUrlList.length }å¼ å›¾ç‰‡ç­‰å¾…ä¸‹è½½ä¸­ï¼Œè¯·ç¨å€™`)
                this.sleep()
            },
            // æµ·è´¼ç‹ä¹”å·´å•é¡µçš„é€»è¾‘ï¼Œè¿™ä¸ªç½‘ç«™éœ€è¦åšä¸¤æ¬¡æ“ä½œï¼Œå…ˆé€šè¿‡å…³é”®è¯æŸ¥è¯¢å‡ºç›¸å…³æ•°æ®é›†åˆï¼Œç„¶åè¿›è¯¦æƒ…ï¼Œæ‰èƒ½å¾—åˆ°æˆ‘ä»¬æƒ³è¦çš„æ•°æ®
            async 'wallpaperaccess.com'() {
                const websiteHtml = await axiosRequest.get(`${this.reptileUrl}`)
                const $ = cheerio.load(websiteHtml);
                let menuList = []
                $('.collection_thumb a').each((i, v) => {
                    menuList.push(`https://wallpaperaccess.com${v.attribs['href']}`)
                })
                log.info(`å½“å‰é¡µé¢å…±æœ‰  ${ menuList.length }  ä¸ªä¸»é¢˜`)
                menuList.map(v => {
                    return axiosRequest.get(v).then(res => {
                        const $_children = cheerio.load(res);
                        $_children('.thumb').each((i, v) => {
                            const smallUrl = v.attribs['data-src'] || v.attribs.src
                            const fileName = smallUrl.split('/')[2]
                            const fullUrl = `https://wallpaperaccess.com/${smallUrl}`
                            const fileSize = $_children('.image_cap span').eq(i).html().substring(0, 10)
                            smallUrl && this.imgUrlList.push({
                                smallUrl: fullUrl,
                                fullUrl: fullUrl,
                                fileName,
                                fileSize,
                            })
                        })
                        console.log(`${this.imgUrlList.length}  å¼ å›¾ç‰‡ç­‰å¾…ä¸‹è½½ä¸­`)
                    })
                })
                this.finishHandle()
            }
        }
    }


    /**
     * çˆ¬è™«æœ€åçš„æ“ä½œï¼Œä¸‹è½½å›¾ç‰‡ï¼Œç”ŸæˆæŠ¥å‘Šï¼Œå­˜å‚¨æ•°æ®
     */
    finishHandle() {
        log.info(this.imgUrlList.length, 'this.imgUrlList')
        log.error('è¶…å‡ºæœ€å¤§é¡µæ•°ï¼Œåœæ­¢æ”¶é›†æºæ•°æ®ï¼Œå¼€å§‹çˆ¬å–å›¾ç‰‡~')
        this.downloadPicture()
        const downloadTimer = setInterval(() => {
            if (!this.imgUrlList.length) {
                clearInterval(downloadTimer)
                log.error('çˆ¬å–å›¾ç‰‡å®Œæ¯•ï¼Œç´¯æ­»å’¯ï¼Œå¼€å§‹å­˜å‚¨æ•°æ®å’Œç”ŸæˆæŠ¥å‘Š~~')
                this.exportExcelFile()
                this.connectMysql()
                return false
            }
            log.info(`å¼€å§‹è½®è¯¢ä¸‹è½½å›¾ç‰‡~, å‰©ä½™ ${this.imgUrlList.length} ä¸ªæœªä¸‹è½½`)
            this.downloadPicture()
        }, 10000);
    }
    /**
     * è½®è¯¢,é€’å½’æŸ¥è¯¢åœ°å€
     */
    sleep() {
        const handleTypeStrategy = {
            'paging'() {
                this.currentPage++
                if (this.currentPage > this.maxPage) {
                    this.finishHandle()
                    return false
                }
                const sleepTimeout = commonUtils.getRandomNumber(1, 10)
                let copyTimeout = sleepTimeout
                log.info(`çˆ¬å¤ªå¤šäº†ï¼Œæœ‰ç‚¹ç´¯äº†ï¼Œä¼‘æ¯${sleepTimeout}ç§’ï¼Œåå†ç»§ç»­ğŸ˜„`)
                let logTimer = null
                clearInterval(logTimer)
                logTimer = setInterval(() => {
                    if (copyTimeout <= 1) {
                        clearInterval(logTimer)
                    }
                    log.success(`å€’è®¡æ—¶  ${copyTimeout--}   ç§’åå¼€å§‹ç»§ç»­å¹²æ´»~`)
                }, 1000);

                setTimeout(() => {
                    this.init()
                }, sleepTimeout * 1000);
            },
        }

        const fn = handleTypeStrategy[this.handleType]
        if (fn && typeof fn === 'function') {
            fn.apply(this)
        } else {
            log.error('sleepæ–¹æ³•å¼‚å¸¸ï¼Œæ²¡æœ‰å¤„ç†çš„æ–¹å¼ï¼Œç¨‹åºç»ˆæ­¢å’¯ï¼ï¼ï¼')
            return false
        }
    }
    /**
     * ä¸‹è½½å›¾ç‰‡
     * @return {promise} è¿”å›ä¸‹è½½å›¾ç‰‡çš„promiseé›†åˆ
     */
    downloadPicture() {
        if (!this.imgUrlList.length) {
            return false
        }
        log.info('å¼€å§‹å‘é€è¯·æ±‚ä¸‹è½½å›¾ç‰‡~')
        return this.imgUrlList.splice(0, 10).reduce((accumulator, currentValue, currentIndex, array) => {
            const promise = axiosRequest.get(currentValue.fullUrl, {
                responseType: 'stream'
            }).then(res => {
                this.uploadSuccessArray.push(currentValue)
                const result = res.pipe(fs.createWriteStream(`${this.saveDir}${currentValue.fileName}`))
                log.success(`æˆåŠŸä¿å­˜å›¾ç‰‡åˆ°æœ¬åœ°ï¼Œä¿å­˜ä½ç½®==>${this.saveDir}${currentValue.fileName}`)
            }).catch(err => {
                log.error(err)
                this.uploadFailArray.push(currentValue)
                log.error(`çˆ¬å–å›¾ç‰‡å¤±è´¥ ï¼Œå›¾ç‰‡åœ°å€==> ${currentValue.fullUrl}`)
            })
            accumulator.push(promise)
            return accumulator
        }, [])
    }
    /**
     *  è¿æ¥æ•°æ®åº“
     */
    connectMysql() {
        log.info('å¼€å§‹è½½å…¥æ•°æ®åº“é…ç½®~');
        var mysql = require('mysql2');
        var connection = mysql.createConnection({
            host: 'localhost',
            user: 'root',
            password: 'root',
            database: 'reptile-picture'
        });
        log.info('å‡†å¤‡å…³é—­æ•°æ®åº“è¿æ¥~')
        connection.connect();
        // æ’å…¥å•æ¡å€¼
        // const  addSql = `INSERT INTO picture_info(fileName,fileSize,source,fullUrl,smallUrl, status) VALUES(0,1,2,3,4,5)`;
        const newArray = []
        this.uploadSuccessArray.forEach(v => {
            const {
                fullUrl,
                smallUrl,
                fileName,
                fileSize
            } = v || {}
            const itemArray = [fileName, fileSize, this.reptileUrl, fullUrl, smallUrl, 1]
            newArray.push(itemArray)
        })
        this.uploadFailArray.forEach(v => {
            let {
                fullUrl,
                smallUrl,
                fileName,
                fileSize
            } = v || {}
            // TODO wallhaven.cc çš„ç½‘ç«™æ‰å¯ä»¥è¿™ä¹ˆé«˜å“¦ å¤§éƒ¨åˆ†å°å›¾æ˜¯.jpg ï¼Œ ä½†æ˜¯å¤§å›¾æ˜¯.png çš„ï¼Œå°±è½¬åŒ–ä¸€ä¸‹ï¼Œä¸è¡Œå°±ç®—å’¯
            // fullUrl = fullUrl.replace(/.{1,4}$/, '.png')
            const itemArray = [fileName, fileSize, this.reptileUrl, fullUrl, smallUrl, 0]
            newArray.push(itemArray)
        })


        // æ’å…¥å¤šæ¡å€¼æœ‰é‡å¤çš„ä¸æ’å…¥ï¼Œå¿…é¡»è®¾ç½®ä¸»é”®ï¼Œä¸ç„¶ä¸ç”Ÿæ•ˆ
        const addSql = `INSERT IGNORE  INTO picture_info(fileName,fileSize,source,fullUrl,smallUrl,status) VALUES ?`;
        //å¢
        log.info('å¼€å§‹æ‰¹é‡æ’å…¥æ•°æ®~')
        connection.query(addSql, [newArray], function(err, result) {
            if (err) {
                log.error(`æ’å…¥æ•°æ®åº“å¤±è´¥ ==>  ,${ err.message }`)
                return;
            }
            log.success('æ’å…¥æ•°æ®åº“æˆåŠŸ ==>   ', result);
        });
        log.info('å‡†å¤‡å…³é—­æ•°æ®åº“è¿æ¥~')
        connection.end();
    }
    /**
     *  ç”Ÿæˆexcel æŠ¥å‘Š
     */
    exportExcelFile() {
        log.info('å¼€å§‹ç”ŸæˆexcelæŠ¥å‘Š~')
        // å¯¼å‡ºexcel
        const ExcelJS = require('exceljs');
        const workbook = new ExcelJS.Workbook()
        const worksheet = workbook.addWorksheet('My Sheet');
        workbook.creator = 'Me';
        workbook.lastModifiedBy = 'Her';
        workbook.created = new Date();
        workbook.modified = new Date();
        workbook.lastPrinted = new Date();;


        log.success(`æˆåŠŸä¿å­˜ ${this.uploadSuccessArray.length} ä¸ª`)
        log.success(`ä¿å­˜å¤±è´¥ ${this.uploadFailArray.length} ä¸ª`)

        const newArray = []
        this.uploadSuccessArray.forEach(v => {
            const {
                fullUrl,
                smallUrl,
                fileName,
                fileSize
            } = v || {}
            const itemArray = [fileName, fileSize, this.reptileUrl, fullUrl, smallUrl, 'æˆåŠŸ']
            newArray.push(itemArray)
        })
        this.uploadFailArray.forEach(v => {
            const {
                fullUrl,
                smallUrl,
                fileName,
                fileSize
            } = v || {}
            const itemArray = [fileName, fileSize, this.reptileUrl, fullUrl, smallUrl, 'å¤±è´¥']
            newArray.push(itemArray)
        })



        // å°†è¡¨æ ¼æ·»åŠ åˆ°å·¥ä½œè¡¨
        worksheet.addTable({
            name: 'MyTable',
            ref: 'A1',
            headerRow: true,
            // totalsRow: true,
            style: {
                theme: 'TableStyleLight1'
            },
            columns: [{
                    name: 'æ–‡ä»¶å',
                    width: 50,
                },
                {
                    name: 'å›¾ç‰‡å¤§å°',
                    width: 50,
                },
                {
                    name: 'æ¥æº',
                    width: 50,
                },
                {
                    name: 'å¤§å›¾åœ°å€',
                    width: 50,
                },
                {
                    name: 'å°å›¾åœ°å€',
                    width: 50,
                },
                {
                    name: 'æ˜¯å¦æˆåŠŸä¸‹è½½',
                    width: 50,
                },
            ],
            rows: newArray,
        });

        // å†™å…¥æ–‡ä»¶
        workbook.xlsx.writeFile(`${this.excelFileName}.xlsx`);
        log.success('ç”ŸæˆexcelæŠ¥å‘ŠæˆåŠŸ~')
    }
}


//è°ƒç”¨æ–¹å¼1ï¼š wallhaven.cc ç½‘ç«™è°ƒç”¨å…¥å£
new Reptile({
    reptileUrl: 'https://wallhaven.cc/hot?page=',
    saveDir: 'E:/myExpressDownload/hot/',
    maxPage: 3,
})

// è°ƒç”¨æ–¹å¼2ï¼š wallpaperaccess.com ç½‘ç«™è°ƒç”¨å…¥å£
// new Reptile({
//     reptileUrl: 'https://wallpaperaccess.com/search?q=one+piece',
//     saveDir: 'E:/myExpressDownload/one-piece222/',
//     handleType: 'search'
// })









/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
    var port = parseInt(val, 10);

    if (isNaN(port)) {
        // named pipe
        return val;
    }

    if (port >= 0) {
        // port number
        return port;
    }

    return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
    if (error.syscall !== 'listen') {
        throw error;
    }

    var bind = typeof port === 'string' ?
        'Pipe ' + port :
        'Port ' + port;

    // handle specific listen errors with friendly messages
    switch (error.code) {
        case 'EACCES':
            console.error(bind + ' requires elevated privileges');
            process.exit(1);
            break;
        case 'EADDRINUSE':
            console.error(bind + ' is already in use');
            process.exit(1);
            break;
        default:
            throw error;
    }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
    var addr = server.address();
    var bind = typeof addr === 'string' ?
        'pipe ' + addr :
        'port ' + addr.port;
    debug('Listening on ' + bind);
}

/**
 *è·å–æœ¬åœ°IP
 *
 * @param {boolean}  æ˜¯å¦æ˜¾ç¤ºipb6
 * @returns {object} åŒ…å«Ipçš„æ•°ç»„
 *
 * console.log('æœ¬æœºipåœ°å€(ä¸åŒ…æ‹¬Ipv6):', getLocalIps());
 * console.log('æœ¬æœºipåœ°å€(åŒ…æ‹¬Ipv6):', getLocalIps(true));
 *
 */
function getLocalIps(flagIpv6) {
    var ifaces = os.networkInterfaces();
    var ips = [];
    var func = function(details) {
        if (!flagIpv6 && details.family === 'IPv6') {
            return;
        }
        ips.push(details.address);
    };
    for (var dev in ifaces) {
        ifaces[dev].forEach(func);
    }
    return ips;
}